<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Système solaire</title>
    <link rel="stylesheet" href="CSS/style.css">
</head>
<body>
<div id="divAlert" class="divAlert">
    <h1>Warning</h1>
</div>
<div class="content" id="content">
    <div class="loader">
<!--        <?php-->
<!--                for($i=0;$i<16;$i++){-->
<!--                    echo '<span style="&#45;&#45;i:'.$i.'"></span>';-->
<!--        }-->
<!--        ?>-->
        <span style="--i:0"></span>
        <span style="--i:1"></span>
        <span style="--i:2"></span>
        <span style="--i:3"></span>
        <span style="--i:4"></span>
        <span style="--i:5"></span>
        <span style="--i:6"></span>
        <span style="--i:7"></span>
        <span style="--i:8"></span>
        <span style="--i:9"></span>
        <span style="--i:10"></span>
        <span style="--i:11"></span>
        <span style="--i:12"></span>
        <span style="--i:13"></span>
        <span style="--i:14"></span>
        <span style="--i:15"></span>
    </div>
    <h1 id="loader"></h1>
</div>
<script type="module">
    import * as THREE from '../three.js-master/build/three.module.js';
    import { OrbitControls } from '../three.js-master/examples/jsm/controls/OrbitControls.js';
    import {GUI} from "../three.js-master/examples/jsm/libs/dat.gui.module.js";
    import Stats from '../three.js-master/examples/jsm/libs/stats.module.js';
    import { GLTFLoader } from '../three.js-master/examples/jsm/loaders/GLTFLoader.js';
    import { FlyControls } from '../three.js-master/examples/jsm/controls/FlyControls.js';

    let scene, camera, renderer, stats, clock, controls;
    let helpSphere, sun, mercury, mars, earth, clouds, earthNight, earthNightGhost, earthGhost, moon, venus, jupiter, saturn, ring, uranus, neptune, spaceship, spaceshipGhost;

    let uniforms

    let alpha_mercury = 0;
    let alpha_venus = 15
    let alpha_moon = 10;
    let alpha_earth = 10;
    let alpha_mars = 20
    let alpha_jupiter = 0
    let alpha_saturn = 10
    let alpha_uranus = 15
    let alpha_neptune = 20

    let alpha_speed = 0.001;

    let divStats = true



    const Z = 'z'
    const Q = 'q'
    const S = 's'
    const D = 'd'
    const SHIFT = 'shift'
    const SPACE = ' '
    const CTRL = 'control'
    const DIRECTIONS = [Z, Q, S, D]

    // temporary data
    let walkDirection = new THREE.Vector3()
    let rotateAngle = new THREE.Vector3(0, 1, 0)
    let rotateQuaternion = new THREE.Quaternion()
    let cameraTarget = new THREE.Vector3()

    // constants
    let fadeDuration = 0.2
    let maxSpeed = 100
    let minSpeed = 50


    // CONTROL KEYS
    const keysPressed = {  }
    document.addEventListener('keydown', (event) => {
        (keysPressed)[event.key.toLowerCase()] = true
    }, false);
    document.addEventListener('keyup', (event) => {
        (keysPressed)[event.key.toLowerCase()] = false
    }, false);

    const vs = `
varying vec2 vUv;
varying vec3 vNormal;

void main() {
  vUv = uv;
  vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
  vNormal = normalMatrix * normal;
  gl_Position = projectionMatrix * mvPosition;
}
`;

    const fs = `
uniform sampler2D dayTexture;
uniform sampler2D nightTexture;

uniform vec3 sunDirection;

varying vec2 vUv;
varying vec3 vNormal;

void main( void ) {
  vec3 dayColor = texture2D( dayTexture, vUv ).rgb;
  vec3 nightColor = texture2D( nightTexture, vUv ).rgb;

  // compute cosine sun to normal so -1 is away from sun and +1 is toward sun.
  float cosineAngleSunToNormal = dot(normalize(vNormal), sunDirection);

  // sharpen the edge beween the transition
  cosineAngleSunToNormal = clamp( cosineAngleSunToNormal * 10.0, -1.0, 1.0);

  // convert to 0 to 1 for mixing
  float mixAmount = cosineAngleSunToNormal * 0.5 + 0.5;

  // Select day or night texture based on mix.
  vec3 color = mix( nightColor, dayColor, mixAmount );

  gl_FragColor = vec4( color, 1.0 );
}

`;

    // SPACESHIP
    // -----------------------------------------
    // Load a glTF resource
    const loader = new GLTFLoader()
    loader.load(
        '../three.js-master/examples/models/spaceshipV2/scene.gltf',
        function (gltf) {
            gltf.scene.traverse(function (child) {
                if ((child).isMesh) {
                    let m = child
                    m.receiveShadow = true
                    m.castShadow = true
                }
                if ((child).isLight) {
                    let l = child
                    l.castShadow = true
                    l.shadow.bias = -0.003
                    l.shadow.mapSize.width = 2048
                    l.shadow.mapSize.height = 2048
                }
            })
            spaceship = gltf.scene
            spaceship.position.set(0,0,0)
            spaceship.scale.set(1.2,1.2,1.2)
            document.getElementById('content').style.visibility='hidden'
            document.getElementById('loader').style.visibility='hidden'
            init();
            animate();
        },
        (xhr) => {
            let txt = (xhr.loaded / xhr.total) * 100 + '%'
            document.getElementById("loader").innerText = txt
        },
        (error) => {
            console.log(error)
        }
    )


    function init(){
        clock = new THREE.Clock();

        camera = new THREE.PerspectiveCamera(45, window.innerWidth/innerHeight,1,10000);

        scene = new THREE.Scene();

        // const axesHelper = new THREE.AxesHelper( 200 );
        // scene.add( axesHelper );

        // SUN
        // -----------------------------------------
        const sunTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_sun.jpg" );

        const sunGeometry = new THREE.SphereGeometry( 150, 32, 16 );
        const sunMaterial = new THREE.MeshBasicMaterial( { map:sunTexture, side: THREE.DoubleSide} );
        sun = new THREE.Mesh( sunGeometry, sunMaterial );
        scene.add( sun );
        // ------------------------------------------

        // MERCURY
        // -----------------------------------------
        const mercuryTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_mercury.jpg" );

        const mercuryGeometry = new THREE.SphereGeometry( 10, 32, 16 );
        const mercuryMaterial = new THREE.MeshStandardMaterial( { map:mercuryTexture} );
        mercury = new THREE.Mesh( mercuryGeometry, mercuryMaterial );
        mercury.castShadow = true; //default is false
        mercury.receiveShadow = true; //default
        scene.add( mercury );
        // ------------------------------------------

        // MARS
        // -----------------------------------------
        const marsTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_mars.jpg" );

        const marsGeometry = new THREE.SphereGeometry( 18, 32, 16 );
        const marsMaterial = new THREE.MeshStandardMaterial( { map:marsTexture} );
        mars = new THREE.Mesh( marsGeometry, marsMaterial );
        mars.castShadow = true; //default is false
        mars.receiveShadow = true; //default
        scene.add( mars );
        // ------------------------------------------

        // EARTH GHOST
        // -----------------------------------------
        // const earthGhostTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_clouds.jpg" );

        const earthGhostGeometry = new THREE.SphereGeometry( 10, 32, 16 );
        const earthGhostMaterial = new THREE.MeshStandardMaterial( { color:0xfff} );
        earthGhost = new THREE.Mesh( earthGhostGeometry, earthGhostMaterial );
        // earthGhost.visible = false
        earthGhost.rotation.z = Math.PI / 6
        scene.add( earthGhost );
        // ------------------------------------------

        const dayTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_earth.jpg" );
        const nightTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_nightmap2.jpg" );
        uniforms = {
            sunDirection: {value: new THREE.Vector3(0,1,0) },
            dayTexture: { value: dayTexture},
            nightTexture: { value: nightTexture}
        };

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: uniforms,
            vertexShader: vs,
            fragmentShader: fs,
        });

        // EARTH
        // -----------------------------------------
        const earthTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_earth.jpg" );
        const earthNormalMap = new THREE.TextureLoader().load( "../three.js-master/examples/textures/earth_normal_map.jpg" );
        const earthRoughMap = new THREE.TextureLoader().load( "../three.js-master/examples/textures/earth_spec.jpg" );

        const earthGeometry = new THREE.SphereGeometry( 25, 64, 32 );
        earth = new THREE.Mesh( earthGeometry, shaderMaterial );
        earth.castShadow = true; //default is false
        earth.receiveShadow = true; //default
        earthGhost.add( earth );
        // ------------------------------------------

        // EARTH CLOUD
        // -----------------------------------------
        const cloudTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_clouds.jpg" );
        // const earthNormalMap = new THREE.TextureLoader().load( "../three.js-master/examples/textures/earth_normal_map.jpg" );

        const cloudGeometry = new THREE.SphereGeometry( 25.5, 64, 32 );
        const cloudMaterial = new THREE.MeshStandardMaterial( { alphaMap:cloudTexture, transparent: true} );
        clouds = new THREE.Mesh( cloudGeometry, cloudMaterial );
        clouds.castShadow = true; //default is false
        clouds.receiveShadow = true; //default
        earthGhost.add( clouds );
        // ------------------------------------------
        // // EARTH NIGHT GHOST
        // // -----------------------------------------
        // // const earthGhostTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_clouds.jpg" );
        //
        // earthNightGhost = new THREE.Mesh( earthGhostGeometry, earthGhostMaterial );
        // // earthGhost.visible = false
        // earthNightGhost.rotation.z = Math.PI / 6
        // scene.add( earthNightGhost );
        // // ------------------------------------------
        //
        // // EARTH NIGHT
        // // -----------------------------------------
        // const earthNightTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_nightmap2.jpg" );
        //
        // const earthNightGeometry = new THREE.SphereGeometry( 25, 64, 32 );
        // const earthNightMaterial = new THREE.MeshBasicMaterial( { map:earthNightTexture, normalMap:earthNormalMap} );
        // earthNight = new THREE.Mesh( earthNightGeometry, earthNightMaterial );
        // earthNight.castShadow = true; //default is false
        // earthNight.receiveShadow = true; //default
        // earthNightGhost.add( earthNight );
        // // ------------------------------------------

        // MOON
        // -----------------------------------------
        const moonTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_moon.jpg" );

        const moonGeometry = new THREE.SphereGeometry( 5, 32, 16 );
        const moonMaterial = new THREE.MeshStandardMaterial( { map:moonTexture} );
        moon = new THREE.Mesh( moonGeometry, moonMaterial );
        moon.castShadow = true; //default is false
        moon.receiveShadow = true; //default
        scene.add( moon );
        // ------------------------------------------

        // VENUS
        // -----------------------------------------
        const venusTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_venus.jpg" );

        const venusGeometry = new THREE.SphereGeometry( 25, 32, 16 );
        const venusMaterial = new THREE.MeshStandardMaterial( { map:venusTexture} );
        venus = new THREE.Mesh( venusGeometry, venusMaterial );
        venus.castShadow = true; //default is false
        venus.receiveShadow = true; //default
        scene.add( venus );
        // ------------------------------------------

        // JUPITER
        // -----------------------------------------
        const jupiterTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_jupiter.jpg" );

        const jupiterGeometry = new THREE.SphereGeometry( 40, 32, 16 );
        const jupiterMaterial = new THREE.MeshStandardMaterial( { map:jupiterTexture} );
        jupiter = new THREE.Mesh( jupiterGeometry, jupiterMaterial );
        jupiter.castShadow = true; //default is false
        jupiter.receiveShadow = true; //default
        scene.add( jupiter );
        // ------------------------------------------

        // SATURN
        // -----------------------------------------
        const saturnTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_saturn.jpg" );

        const saturnGeometry = new THREE.SphereGeometry( 40, 32, 16 );
        const saturnMaterial = new THREE.MeshStandardMaterial( { map:saturnTexture} );
        saturn = new THREE.Mesh( saturnGeometry, saturnMaterial );
        saturn.castShadow = true; //default is false
        saturn.receiveShadow = true; //default
        scene.add( saturn );
        // ------------------------------------------

        // RING
        // ------------------------------------------
        const ringTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_ring.png" );
        const ringGeometry = new THREE.RingGeometry( 50, 60, 32 );
        const ringMaterial = new THREE.MeshStandardMaterial( { map:ringTexture, side: THREE.DoubleSide } );
        ring = new THREE.Mesh( ringGeometry, ringMaterial );
        ring.rotation.x=1.2;
        ring.castShadow = true; //default is false
        ring.receiveShadow = true; //default
        scene.add( ring );
        //-------------------------------------------

        // URANUS
        // -----------------------------------------
        const uranusTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_uranus.jpg" );

        const uranusGeometry = new THREE.SphereGeometry( 40, 32, 16 );
        const uranusMaterial = new THREE.MeshStandardMaterial( { map:uranusTexture} );
        uranus = new THREE.Mesh( uranusGeometry, uranusMaterial );
        uranus.castShadow = true; //default is false
        uranus.receiveShadow = true; //default
        scene.add( uranus );
        // ------------------------------------------

        // NEPTUNE
        // -----------------------------------------
        const neptuneTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_neptune.jpg" );

        const neptuneGeometry = new THREE.SphereGeometry( 40, 32, 16 );
        const neptuneMaterial = new THREE.MeshStandardMaterial( { map:neptuneTexture} );
        neptune = new THREE.Mesh( neptuneGeometry, neptuneMaterial );
        neptune.castShadow = true; //default is false
        neptune.receiveShadow = true; //default
        scene.add( neptune );
        // ------------------------------------------

        // HELPER
        // -----------------------------------------
        // const earthGhostTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_clouds.jpg" );

        const helpSphereGeometry = new THREE.SphereGeometry( 30, 32, 16 );
        const helpSphereMaterial = new THREE.MeshBasicMaterial( { color:0xfff} );
        helpSphere = new THREE.Mesh( helpSphereGeometry, helpSphereMaterial );
        helpSphere.visible = false
        scene.add( helpSphere );
        // ------------------------------------------

        // SKYBOX
        // ------------------------------------------
        const skyBoxTexture = new THREE.TextureLoader().load( "../three.js-master/examples/textures/2k_stars_milky_way.jpg" );

        const skyBoxGeometry = new THREE.SphereGeometry( 3000, 32, 16 );
        const skyBoxMaterial = new THREE.MeshBasicMaterial( { map:skyBoxTexture, side: THREE.DoubleSide } );
        const skyBox = new THREE.Mesh( skyBoxGeometry, skyBoxMaterial );
        scene.add( skyBox );
        // ------------------------------------------


        // STATS
        // ------------------------------------------
        stats = new Stats();

        // GUI
        // ------------------------------------------
        const gui = new GUI()
        const folder1 = gui.addFolder( 'Général' );
        const folder2 = gui.addFolder( 'Vaisseau' );
        const params = {
            speed:1,
            minSpeed:minSpeed,
            maxSpeed:maxSpeed,
            fps:true,
        }
        folder1.add(params,'speed',-100,100).step(0.1).name('Vitesse').onChange(function (v){
            alpha_speed = v/1000;
            render();
        })
        folder2.add(params,'minSpeed',20,50).step(1).name('Vitesse minimale du vaisseau').onChange(function(v){
            minSpeed = v;
            render();
        })
        folder2.add(params,'maxSpeed',100,150).step(1).name('Vitesse maximale du vaisseau').onChange(function(v){
            maxSpeed = v;
            render();
        })
        folder1.add(params,'fps').name('Statistiques').onChange(function(v){
            divStats = v
            if(divStats) {
                document.body.appendChild(stats.dom);
            }else{
                document.body.removeChild(stats.dom)
            }
            render()
        })
        // ------------------------------------------


        if(divStats) {
            document.body.appendChild(stats.dom);
        }else{
            document.body.removeChild(stats.dom)
        }

        // ------------------------------------------

        // LIGHT & SHADOW
        // ------------------------------------------

        //Create a PointLight and turn on shadows for the light
        const light = new THREE.PointLight( 0xffffff, 1, 0 );
        light.position.set( 0, 0, 10 );
        light.castShadow = true; // default false
        scene.add( light );

        //Set up shadow properties for the light
        light.shadow.mapSize.width = 512; // default
        light.shadow.mapSize.height = 512; // default
        light.shadow.camera.near = 0.5; // default
        light.shadow.camera.far = 10000; // default
        // -----------------------------------------





        const ambientLight = new THREE.AmbientLight( 0x404040 ); // soft white light
        // scene.add( ambientLight );

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap; // default THREE.PCFShadowMap
        document.body.appendChild( renderer.domElement );
        onWindowResize();
        window.addEventListener( 'resize', onWindowResize );

        // FLY
        // const controls = new FlyControls( camera, renderer.domElement );
        //
        // controls.movementSpeed = 1000;
        // controls.domElement = renderer.domElement;
        // controls.rollSpeed = Math.PI / 24;
        // controls.autoForward = false;
        // controls.dragToLook = false;
        //

        // ORBIT CONTROL
        controls = new OrbitControls( camera, renderer.domElement );
        // controls.enableDamping = true
        // controls.minDistance = 5
        // controls.maxDistance = 15
        // controls.enablePan = false
        // controls.maxPolarAngle = Math.PI / 2 - 0.05
        //controls.update() must be called after any manual changes to the camera's transform

        // SPACESHIP GHOST
        // -----------------------------------------
        const spaceshipGhostGeometry = new THREE.SphereGeometry( 10, 32, 16 );
        const spaceshipGhostMaterial = new THREE.MeshStandardMaterial( { color:0xfff} );
        spaceshipGhost = new THREE.Mesh( spaceshipGhostGeometry, spaceshipGhostMaterial );
        scene.add( spaceshipGhost );
        // ------------------------------------------

        spaceshipGhost.add( spaceship);
        spaceship.scale.set(1.2,1.2,1.2)
        spaceshipGhost.position.set(0,300,495);
        camera.position.set(0,300,500);

        // controls.update();
    }

    function animate() {

        requestAnimationFrame( animate );

        uniforms.sunDirection.value.x = Math.abs(earthGhost.position.x - sun.position.x);
        uniforms.sunDirection.value.z = Math.abs(earthGhost.position.z - sun.position.z);
        uniforms.sunDirection.value.y = Math.abs(earthGhost.position.y - sun.position.y);

        let distToSun = new THREE.Vector3(spaceshipGhost.position.x,
                                        spaceshipGhost.position.y,
                                        spaceshipGhost.position.z)
        distToSun = Math.sqrt(Math.pow(distToSun.x,2)+Math.pow(distToSun.y,2)+Math.pow(distToSun.z,2))

        let distToEarth = new THREE.Vector3((spaceshipGhost.position.x - earthGhost.position.x),
                                            (spaceshipGhost.position.y - earthGhost.position.y),
                                            (spaceshipGhost.position.z - earthGhost.position.z))
        distToEarth = Math.sqrt(Math.pow(distToEarth.x,2)+Math.pow(distToEarth.y,2)+Math.pow(distToEarth.z,2))

        let distToMercury = new THREE.Vector3((spaceshipGhost.position.x - mercury.position.x),
            (spaceshipGhost.position.y - mercury.position.y),
            (spaceshipGhost.position.z - mercury.position.z))
        distToMercury = Math.sqrt(Math.pow(distToMercury.x,2)+Math.pow(distToMercury.y,2)+Math.pow(distToMercury.z,2))

        let distToVenus = new THREE.Vector3((spaceshipGhost.position.x - venus.position.x),
            (spaceshipGhost.position.y - venus.position.y),
            (spaceshipGhost.position.z - venus.position.z))
        distToVenus = Math.sqrt(Math.pow(distToVenus.x,2)+Math.pow(distToVenus.y,2)+Math.pow(distToVenus.z,2))

        if(distToSun<170||distToEarth < 35 || distToMercury < 20 || distToVenus < 35){
            if(!document.getElementById('divAlert').classList.contains('alert')){
                document.getElementById('divAlert').classList.add('alert')
            }
        }else{
            if(document.getElementById('divAlert').classList.contains('alert')){
                document.getElementById('divAlert').classList.remove('alert')
            }
        }

        // console.log("x:"+spaceship.position.x+"\ny:"+spaceship.position.y+"\nz:"+spaceship.position.z)

        let mixerUpdateDelta = clock.getDelta();

        if(keysPressed[Z]===true || keysPressed[Q]===true || keysPressed[S]===true || keysPressed[D] === true || keysPressed[CTRL] === true || keysPressed[SPACE] === true) {
            // calculate towards camera direction
            var angleYCameraDirection = Math.atan2(
                (camera.position.x - spaceshipGhost.position.x),
                (camera.position.z - spaceshipGhost.position.z))
            // diagonal movement angle offset
            var directionOffset = getDirectionOffset()

            // let rotateAngleX = new THREE.Vector3(1,0,0)

            // let rotateQuaternionX = new THREE.Quaternion()
            // rotateQuaternionX.setFromAxisAngle(rotateAngleX, angleXCameraDirection + keysPressed[SPACE]?Math.PI/4:keysPressed[CTRL]?-Math.PI/4:0)
            let offsetX
            if(keysPressed[SPACE] === true){
                offsetX = Math.PI/4
            }else if(keysPressed[CTRL] === true){
                offsetX = -Math.PI/4
            }else{
                offsetX = 0
            }

            // spaceship.rotation.z = angleZCameraDirection


            // calculate direction
            camera.getWorldDirection(walkDirection)
            walkDirection.y = (keysPressed[SPACE])?10:(keysPressed[CTRL])?-10:0
            walkDirection.normalize()
            walkDirection.applyAxisAngle(rotateAngle, directionOffset)
            let axeX = new THREE.Vector3(1,0,0)
            // axeX.applyAxisAngle(new THREE.Vector3(0,1,0),angleXCameraDirection + directionOffset)
            let quaternion = new THREE.Quaternion().setFromAxisAngle( axeX, offsetX );
            // rotate model
            spaceshipGhost.rotation.y = angleYCameraDirection + directionOffset

            spaceship.rotation.x = offsetX

            // run/walk velocity
            const velocity = keysPressed[SHIFT]?maxSpeed:minSpeed

            // move model & camera
            const moveX = walkDirection.x * velocity * mixerUpdateDelta
            const moveZ = walkDirection.z * velocity * mixerUpdateDelta
            const moveY = walkDirection.y * velocity * mixerUpdateDelta
            spaceshipGhost.position.x += moveX
            spaceshipGhost.position.z += moveZ
            spaceshipGhost.position.y += moveY
            updateCameraTarget(moveX, moveZ, moveY)
        }

        sun.rotation.y += alpha_speed;
        mercury.rotation.y += alpha_speed;
        mars.rotation.y += alpha_speed;
        earth.rotation.y += alpha_speed;
        // earthNight.rotation.y += alpha_speed;
        clouds.rotation.y -= alpha_speed;
        // clouds.rotation.z +=alpha_speed/2;
        clouds.rotation.x -= alpha_speed;
        venus.rotation.y += alpha_speed;
        jupiter.rotation.y += alpha_speed;
        saturn.rotation.y += alpha_speed;
        ring.rotation.z += alpha_speed;
        uranus.rotation.y += alpha_speed;
        moon.rotation.y += alpha_speed;
        neptune.rotation.y += alpha_speed;

        mercury.position.x = Math.cos(alpha_mercury)*(180);
        mercury.position.z = Math.sin(alpha_mercury)*(180);
        alpha_mercury += alpha_speed;

        venus.position.x = Math.cos(alpha_venus)*(220);
        venus.position.z = Math.sin(alpha_venus)*(220);
        alpha_venus += 0.9*alpha_speed;

        earthGhost.position.x = Math.cos(alpha_earth)*(285);
        earthGhost.position.z = Math.sin(alpha_earth)*(285);
        // earthNightGhost.position.x = Math.cos(alpha_earth)*(285.07);
        // earthNightGhost.position.z = Math.sin(alpha_earth)*(285.07);

        alpha_earth += 0.8*alpha_speed;

        mars.position.x = Math.cos(alpha_mars)*(355);
        mars.position.z = Math.sin(alpha_mars)*(355);
        alpha_mars += 0.7*alpha_speed;

        moon.position.x =earthGhost.position.x + (Math.cos(alpha_moon)*(35));
        moon.position.z =earthGhost.position.z + (Math.sin(alpha_moon)*(35));
        alpha_moon -= 5 * alpha_speed;

        jupiter.position.x =(Math.cos(alpha_jupiter)*(450));
        jupiter.position.z =(Math.sin(alpha_jupiter)*(450));
        alpha_jupiter -= 0.6*alpha_speed;

        saturn.position.x =(Math.cos(alpha_saturn)*(560));
        saturn.position.z =(Math.sin(alpha_saturn)*(560));
        alpha_saturn -= 0.5*alpha_speed;

        ring.position.x =(Math.cos(alpha_saturn)*(560));
        ring.position.z =(Math.sin(alpha_saturn)*(560));
        alpha_saturn -= 0.4*alpha_speed;

        uranus.position.x =(Math.cos(alpha_uranus)*(700));
        uranus.position.z =(Math.sin(alpha_uranus)*(700));
        alpha_uranus -= 0.3*alpha_speed;

        neptune.position.x =(Math.cos(alpha_neptune)*(900));
        neptune.position.z =(Math.sin(alpha_neptune)*(900));
        alpha_neptune += 0.2*alpha_speed;

        // earth.position.z -= 0.01;
        // earth.position.x = Math.sqrt(Math.pow(210)-Math.pow(earth.position.z));

        //controls.update();
        render()


    }

    function render() {

        renderer.render( scene, camera );
        stats.update();

    }

    function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize( window.innerWidth, window.innerHeight );

    }
    function updateCameraTarget(moveX, moveZ, moveY) {
        // move camera
        camera.position.x += moveX
        camera.position.z += moveZ
        camera.position.y += moveY

        // update camera target
        cameraTarget.x = spaceshipGhost.position.x
        cameraTarget.y = spaceshipGhost.position.y + 1
        cameraTarget.z = spaceshipGhost.position.z
        controls.target = cameraTarget
    }
    function getDirectionOffset() {
        var directionOffset = 0 // z

        if (keysPressed[Z]) {
            if (keysPressed[Q]) {
                directionOffset = Math.PI / 4 // z+q
            } else if (keysPressed[D]) {
                directionOffset = - Math.PI / 4 // z+d
            }
        } else if (keysPressed[S]) {
            if (keysPressed[Q]) {
                directionOffset = Math.PI / 4 + Math.PI / 2 // s+q
            } else if (keysPressed[D]) {
                directionOffset = -Math.PI / 4 - Math.PI / 2 // s+d
            } else {
                directionOffset = Math.PI // s
            }
        } else if (keysPressed[Q]) {
            directionOffset = Math.PI / 2 // q
        } else if (keysPressed[D]) {
            directionOffset = - Math.PI / 2 // d
        }

        return directionOffset
    }

</script>
</body>
</html>